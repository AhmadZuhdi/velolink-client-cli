const BluetoothManager = require('./modules/bluetoothManager');
const KeySimulator = require('./modules/keySimulator');
const ScenarioHandler = require('./modules/scenarioHandler');
const ConfigManager = require('./modules/configManager');
const PortTester = require('./utils/portTester');
const { select, confirm, input } = require('@inquirer/prompts');

class VelolinkClient {
    constructor() {
        this.configManager = new ConfigManager();
        this.bluetoothManager = new BluetoothManager();
        this.keySimulator = new KeySimulator();
        this.scenarioHandler = new ScenarioHandler(this.keySimulator);
        this.portTester = new PortTester();
        
        this.isConnected = false;
        this.port = null;
    }

    async initialize() {
        console.log('üöÄ Initializing Velolink Client...');
        
        try {
            // Initialize configuration manager first
            const configInitialized = await this.configManager.initialize();
            if (!configInitialized) {
                console.warn('‚ö†Ô∏è  Configuration system failed to initialize, using defaults');
            }
            
            // Apply configuration to components
            await this.applyConfiguration();
            
            // Set up event handlers
            this.setupEventHandlers();
            
            // Set up config change handlers
            this.setupConfigHandlers();
            
            console.log('‚úÖ Velolink Client initialized successfully!');
            
        } catch (error) {
            console.error('‚ùå Failed to initialize:', error.message);
        }
    }

    async selectPortManually() {
        try {
            const ports = await this.bluetoothManager.selectPortInteractive();
            
            if (!ports || ports.length === 0) {
                console.log('‚ùå No ports available');
                return false;
            }

            // For programmatic selection, you can use connectByIndex
            // Example: await this.bluetoothManager.connectByIndex(0);
            
            // Or use the interactive prompt
            await this.bluetoothManager.connectWithPrompt();
            return true;
            
        } catch (error) {
            console.error('‚ùå Manual port selection failed:', error.message);
            return false;
        }
    }

    setupEventHandlers() {
        // Handle incoming data from Arduino
        this.bluetoothManager.on('data', (data) => {
            this.scenarioHandler.processData(data);
        });

        // Handle connection events
        this.bluetoothManager.on('connected', async (portPath) => {
            this.isConnected = true;
            console.log('üîó Connected to HC-05 at:', portPath);
            
            // Save last connected port to config
            await this.configManager.set('bluetooth.lastConnectedPort', portPath);
            
            // Show game mode selection after connection
            setTimeout(async () => {
                // Then show data processing control
                setTimeout(async () => {
                    await this.showDataProcessingPrompt();
                }, 1000);
            }, 1000);
        });

        this.bluetoothManager.on('disconnected', () => {
            this.isConnected = false;
            console.log('üîå Disconnected from HC-05');
        });

        this.bluetoothManager.on('error', (error) => {
            console.error('‚ùå Bluetooth error:', error.message);
        });
    }

    setupConfigHandlers() {
        // Handle configuration changes
        this.configManager.on('changed', async (config, changes) => {
            console.log('‚öôÔ∏è  Configuration updated, applying changes...');
            await this.applyConfiguration();
        });

        this.configManager.on('error', (error) => {
            console.error('‚ùå Configuration error:', error.message);
        });
    }

    async applyConfiguration() {
        try {
            const config = this.configManager.getConfig();
            
            // Apply key simulation settings
            const keySimConfig = config.keySimulation || {};
            if (keySimConfig.gameMode !== undefined) {
                this.keySimulator.setGameMode(keySimConfig.gameMode);
            }
            if (keySimConfig.enabled !== undefined && !keySimConfig.enabled) {
                this.keySimulator.disable();
            } else {
                this.keySimulator.enable();
            }
            
            // Apply scenario settings
            const scenarioConfig = config.scenarios || {};
            if (scenarioConfig.gameMode && scenarioConfig.gameMode !== 'default') {
                this.scenarioHandler.setGameMode(scenarioConfig.gameMode);
            }
            if (scenarioConfig.dataProcessingEnabled !== undefined) {
                if (scenarioConfig.dataProcessingEnabled) {
                    this.scenarioHandler.enableDataProcessing();
                } else {
                    this.scenarioHandler.disableDataProcessing();
                }
            }
            
            // Apply bluetooth settings would go here if needed
            // const bluetoothConfig = config.bluetooth || {};
            
            console.log('‚úÖ Configuration applied successfully');
        } catch (error) {
            console.error('‚ùå Failed to apply configuration:', error.message);
        }
    }

    async showMainMenu() {
        let running = true;
        
        while (running) {
            try {
                const processingStatus = this.scenarioHandler.getDataProcessingStatus();
                const statusIcon = processingStatus.enabled ? '‚úÖ' : '‚è∏Ô∏è';
                
                // Get last connection info for quick start option
                const config = this.configManager.getConfig();
                const lastPort = config.bluetooth?.lastConnectedPort;
                const lastGameMode = config.scenarios?.gameMode || 'default';
                
                const choices = [];
                
                // Add quick start option if we have previous connection info
                if (lastPort && lastGameMode) {
                    const gameModeDisplay = lastGameMode === 'default' ? 'Default' : 
                        this.scenarioHandler.gameModes.get(lastGameMode)?.name || lastGameMode;
                    choices.push({
                        name: `üöÄ Quick Start (${lastPort} + ${gameModeDisplay})`,
                        value: 'quick_start'
                    });
                }
                
                choices.push(
                    { name: 'üìã List available ports', value: 'list_ports' },
                    { name: 'üîå Connect to port manually', value: 'connect_manual' },
                    { name: 'üéÆ Change game mode', value: 'game_mode' },
                    { name: `${statusIcon} ${processingStatus.enabled ? ' Disable' : ' Enable'} data processing`, value: 'toggle_processing' },
                    { name: '‚öôÔ∏è  Configuration settings', value: 'config_menu' },
                    { name: 'üìä Show connection status', value: 'status' },
                    { name: 'üîå Disconnect', value: 'disconnect' },
                    { name: '‚ùå Exit', value: 'exit' }
                );

                if (processingStatus.pendingDataCount > 0) {
                    console.log(`\nüì• ${processingStatus.pendingDataCount} commands waiting to be processed`);
                }

                const choice = await select({
                    message: 'üéØ Velolink Client - Choose an action:',
                    choices: choices,
                    pageSize: 12
                });

                await this.handleMenuChoice(choice);

                running = false;

            } catch (error) {
                if (error.name === 'ExitPromptError') {
                    console.log('\nüëã Goodbye!');
                    this.configManager.destroy();
                    await this.bluetoothManager.disconnect();
                    process.exit(0);
                } else {
                    console.error('‚ùå Menu error:', error.message);
                }
            }
        }
    }

    async handleMenuChoice(choice) {
        switch (choice) {
            case 'quick_start':
                await this.quickStart();
                break;
            case 'list_ports':
                await this.bluetoothManager.listPorts();
                await this.showMainMenu();
                break;
            case 'connect_manual':
                await this.selectPortManually();
                break;
            case 'auto_connect':
                await this.bluetoothManager.autoConnect();
                break;
            case 'test_ports':
                await this.portTester.testAllPorts();
                await this.showMainMenu();
                break;
            case 'game_mode':
                await this.showGameModeSelection();
                await this.showMainMenu();
                break;
            case 'toggle_processing':
                this.toggleDataProcessing();
                await this.showMainMenu();
                break;
            case 'config_menu':
                await this.showConfigMenu();
                await this.showMainMenu();
                break;
            case 'show_pending':
                this.showPendingData();
                await this.showMainMenu();
                break;
            case 'clear_pending':
                this.clearPendingData();
                await this.showMainMenu();
                break;
            case 'test_data':
                await this.sendTestData();
                await this.showMainMenu();
                break;
            case 'status':
                this.showConnectionStatus();
                await this.showMainMenu();
                break;
            case 'disconnect':
                await this.bluetoothManager.disconnect();
                break;
            case 'exit':
                console.log('üëã Goodbye!');
                this.configManager.destroy();
                await this.bluetoothManager.disconnect();
                process.exit(0);
                break;
            default:
                console.log('‚ùå Unknown choice');
        }
    }

    async quickStart() {
        try {
            console.log('\nüöÄ QUICK START MODE');
            console.log('===================');
            
            const config = this.configManager.getConfig();
            const lastPort = config.bluetooth?.lastConnectedPort;
            const lastGameMode = config.scenarios?.gameMode || 'default';
            
            if (!lastPort) {
                console.log('‚ùå No previous connection found. Use manual connection first.');
                return;
            }
            
            console.log(`üì° Connecting to last port: ${lastPort}`);
            console.log(`üéÆ Setting game mode: ${lastGameMode}`);
            
            // Step 1: Connect to the last port
            const baudRate = config.bluetooth?.baudRate || 9600;
            
            try {
                await this.bluetoothManager.connect(lastPort, baudRate);
                
                // Wait a moment for connection to establish
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                if (!this.isConnected) {
                    console.log(`‚ùå Failed to connect to ${lastPort}`);
                    console.log('üí° Device might not be available or port changed');
                    console.log('üí° Try manual connection or check device');
                    return;
                }
                
                console.log(`‚úÖ Successfully connected to ${lastPort}`);
                
            } catch (error) {
                console.log(`‚ùå Connection failed: ${error.message}`);
                console.log('üí° Try manual connection instead');
                return;
            }
            
            // Step 2: Set the last game mode
            if (lastGameMode !== 'default') {
                const gameModeSet = this.scenarioHandler.setGameMode(lastGameMode);
                if (gameModeSet) {
                    const currentMode = this.scenarioHandler.getCurrentGameMode();
                    console.log(`‚úÖ Game mode restored: ${currentMode.name}`);
                } else {
                    console.log(`‚ö†Ô∏è  Game mode '${lastGameMode}' not found, using default`);
                }
            }
            
            // Step 3: Enable data processing based on config
            const dataProcessingEnabled = config.scenarios?.dataProcessingEnabled;
            if (dataProcessingEnabled) {
                this.scenarioHandler.enableDataProcessing();
                console.log('‚úÖ Data processing enabled (from config)');
            } else {
                console.log('‚è∏Ô∏è  Data processing disabled (from config)');
                console.log('üí° Use menu to enable data processing if needed');
            }
            
            // Step 4: Apply key simulation settings
            const keySimConfig = config.keySimulation;
            if (keySimConfig?.gameMode) {
                this.keySimulator.setGameMode(true);
                console.log('üéÆ Game mode enabled for key simulation');
            }
            
            console.log('\nüéØ Quick Start Complete!');
            console.log('========================');
            console.log('‚úÖ Connected to device');
            console.log('‚úÖ Game mode restored');
            console.log('‚úÖ Settings applied');
            console.log('\nüì° Ready to receive Arduino commands!');
            console.log('üí° Tip: Send commands from your Arduino to test the setup');
            
            // Show current mode help after a short delay
            setTimeout(() => {
                console.log('\n');
                this.showGameModeHelp();
            }, 2000);
            
        } catch (error) {
            console.error('‚ùå Quick start failed:', error.message);
            console.log('üí° Try manual connection instead');
        }
    }

    async sendTestData() {
        if (!this.isConnected) {
            console.log('‚ùå Not connected to any device');
            return;
        }

        try {
            console.log('üì§ Sending test data to Arduino...');
            await this.bluetoothManager.sendData('TEST_FROM_PC');
            console.log('‚úÖ Test data sent successfully');
        } catch (error) {
            console.error('‚ùå Failed to send test data:', error.message);
        }
    }

    showConnectionStatus() {
        console.log('\n=== Connection Status ===');
        console.log(`Connected: ${this.isConnected ? '‚úÖ Yes' : '‚ùå No'}`);
        
        if (this.isConnected) {
            console.log(`Port: ${this.bluetoothManager.getCurrentPort()}`);
        }
        
        const currentMode = this.scenarioHandler.getCurrentGameMode();
        const processingStatus = this.scenarioHandler.getDataProcessingStatus();
        
        console.log(`Game Mode: üéÆ ${currentMode.name}`);
        console.log(`Description: ${currentMode.description}`);
        console.log(`Data Processing: ${processingStatus.enabled ? '‚úÖ Enabled' : '‚è∏Ô∏è Disabled'}`);
        
        if (processingStatus.pendingDataCount > 0) {
            console.log(`Pending Commands: üì• ${processingStatus.pendingDataCount}`);
        }
        
        console.log('========================');
    }

    async showGameModeSelection() {
        try {
            console.log('\nüéÆ GAME MODE SELECTION üéÆ');
            console.log('===========================');
            console.log('Choose a game mode for optimal Arduino control:');
            
            const gameModes = this.scenarioHandler.listGameModes();
            
            // Create choices for inquirer
            const choices = [
                { name: 'üéØ Default (Standard scenarios)', value: 0 },
                ...gameModes.map((mode, index) => {
                    const gameMode = this.scenarioHandler.gameModes.get(mode);
                    return {
                        name: `üéÆ ${gameMode.name} - ${gameMode.description}`,
                        value: index + 1
                    };
                })
            ];

            const selection = await select({
                message: 'Select game mode:',
                choices: choices,
                pageSize: 8
            });

            const success = this.scenarioHandler.selectGameModeByIndex(selection);
            
            if (success) {
                const currentMode = this.scenarioHandler.getCurrentGameMode();
                console.log(`\n‚úÖ Game mode activated: ${currentMode.name}`);
                console.log(`üìã ${currentMode.description}`);
                
                // Save game mode to config
                await this.configManager.setGameMode(currentMode.mode);
                
                console.log('\nüéØ Ready to receive Arduino commands!');
                console.log('üì° Send data from your Arduino to trigger actions...');
                
                // Show some example commands for the selected mode
                this.showGameModeHelp();
            }

        } catch (error) {
            if (error.name === 'ExitPromptError') {
                console.log('üö´ Game mode selection cancelled');
                return;
            }
            console.error('‚ùå Error in game mode selection:', error.message);
        }
    }

    async showGameModeHelp() {
        const currentMode = this.scenarioHandler.getCurrentGameMode();
        
        console.log('\nüí° Example Arduino Commands:');
        console.log('============================');
        
        switch (currentMode.mode) {
            case 'racing':
                console.log('BTN1:ON     -> Accelerate');
                console.log('BTN2:ON     -> Brake');
                console.log('LEFT/RIGHT  -> Steer');
                console.log('RPM:5000,4800 -> Gear control');
                break;
                
            case 'fps':
                console.log('BTN1:ON     -> Jump');
                console.log('BTN2:ON     -> Shoot');
                console.log('UP/DOWN     -> Move forward/back');
                console.log('LEFT/RIGHT  -> Strafe left/right');
                break;
                
            case 'media':
                console.log('BTN1:ON     -> Play/Pause');
                console.log('BTN2:ON     -> Next track');
                console.log('UP/DOWN     -> Volume up/down');
                break;
                
            case 'flight':
                console.log('BTN1:ON     -> Landing gear');
                console.log('UP/DOWN     -> Pitch control');
                console.log('LEFT/RIGHT  -> Roll control');
                console.log('RPM:6000,5800 -> Throttle control');
                break;
                
            case 'presentation':
                console.log('BTN1:ON     -> Next slide');
                console.log('BTN2:ON     -> Previous slide');
                console.log('LEFT/RIGHT  -> Navigate slides');
                break;
                
            default:
                console.log('PLAY/PAUSE  -> Media controls');
                console.log('BTN1:ON     -> Space key');
                console.log('UP/DOWN     -> Arrow keys');
                console.log('A0:512      -> Analog sensor');
        }
        console.log('============================\n');
    }

    toggleDataProcessing() {
        const newStatus = this.scenarioHandler.toggleDataProcessing();
        console.log(`\nüîÑ Data processing is now: ${newStatus ? '‚úÖ ENABLED' : '‚è∏Ô∏è DISABLED'}`);
        
        if (newStatus) {
            console.log('üéÆ Arduino commands will now trigger key actions');
        } else {
            console.log('üì• Arduino commands will be buffered until enabled');
        }
        
        // Save the state to config
        this.configManager.setDataProcessingEnabled(newStatus);
    }

    async showConfigMenu() {
        let inConfigMenu = true;
        
        while (inConfigMenu) {
            try {
                const choice = await select({
                    message: '‚öôÔ∏è  Configuration Settings:',
                    choices: [
                        { name: 'üéÆ Key Simulation Settings', value: 'key_simulation' },
                        { name: 'üì° Bluetooth Settings', value: 'bluetooth' },
                        { name: 'üéØ Scenario Settings', value: 'scenarios' },
                        { name: 'üìù Logging Settings', value: 'logging' },
                        { name: 'üìÑ Show Current Config', value: 'show_config' },
                        { name: 'üîÑ Reload Config', value: 'reload_config' },
                        { name: '‚Ü©Ô∏è  Back to Main Menu', value: 'back' }
                    ],
                    pageSize: 10
                });

                switch (choice) {
                    case 'key_simulation':
                        await this.configureKeySimulation();
                        break;
                    case 'bluetooth':
                        await this.configureBluetooth();
                        break;
                    case 'scenarios':
                        await this.configureScenarios();
                        break;
                    case 'logging':
                        await this.configureLogging();
                        break;
                    case 'show_config':
                        this.showCurrentConfig();
                        break;
                    case 'reload_config':
                        await this.reloadConfig();
                        break;
                    case 'back':
                        inConfigMenu = false;
                        break;
                }
            } catch (error) {
                if (error.name === 'ExitPromptError') {
                    inConfigMenu = false;
                } else {
                    console.error('‚ùå Config menu error:', error.message);
                }
            }
        }
    }

    async configureKeySimulation() {
        try {
            const keySimConfig = this.configManager.getKeySimulationConfig();
            
            const choices = [
                { name: `Key Simulation: ${keySimConfig.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}`, value: 'toggle_enabled' },
                { name: `Game Mode: ${keySimConfig.gameMode ? 'üéÆ Enabled' : 'üìù Disabled'}`, value: 'toggle_game_mode' },
                { name: `Delay Between Keys: ${keySimConfig.delayBetweenKeys || 10}ms`, value: 'set_delay' },
                { name: '‚Ü©Ô∏è  Back', value: 'back' }
            ];

            const choice = await select({
                message: 'üéÆ Key Simulation Settings:',
                choices: choices
            });

            switch (choice) {
                case 'toggle_enabled':
                    await this.configManager.setKeySimulationConfig({
                        ...keySimConfig,
                        enabled: !keySimConfig.enabled
                    });
                    console.log(`üéÆ Key simulation ${!keySimConfig.enabled ? 'enabled' : 'disabled'}`);
                    break;
                    
                case 'toggle_game_mode':
                    await this.configManager.setKeySimulationGameMode(!keySimConfig.gameMode);
                    console.log(`üéÆ Game mode ${!keySimConfig.gameMode ? 'enabled' : 'disabled'}`);
                    break;
                    
                case 'set_delay': {
                    const delayInput = await input({
                        message: 'Enter delay between keys (ms):',
                        default: String(keySimConfig.delayBetweenKeys || 10),
                        validate: (value) => {
                            const num = parseInt(value);
                            return !isNaN(num) && num >= 0 && num <= 1000 ? true : 'Please enter a number between 0 and 1000';
                        }
                    });
                    
                    await this.configManager.setKeySimulationConfig({
                        ...keySimConfig,
                        delayBetweenKeys: parseInt(delayInput)
                    });
                    console.log(`‚è±Ô∏è  Delay set to ${delayInput}ms`);
                    break;
                }
                    
                case 'back':
                    return;
            }
        } catch (error) {
            if (error.name !== 'ExitPromptError') {
                console.error('‚ùå Key simulation config error:', error.message);
            }
        }
    }

    async configureBluetooth() {
        try {
            const bluetoothConfig = this.configManager.getBluetoothConfig();
            
            const choices = [
                { name: `Auto Connect: ${bluetoothConfig.autoConnect ? '‚úÖ Enabled' : '‚ùå Disabled'}`, value: 'toggle_auto_connect' },
                { name: `Baud Rate: ${bluetoothConfig.baudRate || 9600}`, value: 'set_baud_rate' },
                { name: `Timeout: ${bluetoothConfig.timeout || 5000}ms`, value: 'set_timeout' },
                { name: '‚Ü©Ô∏è  Back', value: 'back' }
            ];

            const choice = await select({
                message: 'üì° Bluetooth Settings:',
                choices: choices
            });

            switch (choice) {
                case 'toggle_auto_connect':
                    await this.configManager.setBluetoothConfig({
                        ...bluetoothConfig,
                        autoConnect: !bluetoothConfig.autoConnect
                    });
                    console.log(`üì° Auto connect ${!bluetoothConfig.autoConnect ? 'enabled' : 'disabled'}`);
                    break;
                    
                case 'set_baud_rate': {
                    const baudRates = ['9600', '19200', '38400', '57600', '115200'];
                    const baudChoice = await select({
                        message: 'Select baud rate:',
                        choices: baudRates.map(rate => ({ name: rate, value: rate }))
                    });
                    
                    await this.configManager.setBluetoothConfig({
                        ...bluetoothConfig,
                        baudRate: parseInt(baudChoice)
                    });
                    console.log(`üì° Baud rate set to ${baudChoice}`);
                    break;
                }
                    
                case 'set_timeout': {
                    const timeoutInput = await input({
                        message: 'Enter connection timeout (ms):',
                        default: String(bluetoothConfig.timeout || 5000),
                        validate: (value) => {
                            const num = parseInt(value);
                            return !isNaN(num) && num >= 1000 && num <= 30000 ? true : 'Please enter a number between 1000 and 30000';
                        }
                    });
                    
                    await this.configManager.setBluetoothConfig({
                        ...bluetoothConfig,
                        timeout: parseInt(timeoutInput)
                    });
                    console.log(`‚è±Ô∏è  Timeout set to ${timeoutInput}ms`);
                    break;
                }
                    
                case 'back':
                    return;
            }
        } catch (error) {
            if (error.name !== 'ExitPromptError') {
                console.error('‚ùå Bluetooth config error:', error.message);
            }
        }
    }

    async configureScenarios() {
        try {
            const scenarioConfig = this.configManager.getScenariosConfig();
            const currentMode = this.scenarioHandler.getCurrentGameMode();
            
            const choices = [
                { name: `Current Game Mode: ${currentMode.name}`, value: 'change_game_mode' },
                { name: `Data Processing: ${scenarioConfig.dataProcessingEnabled ? '‚úÖ Enabled' : '‚ùå Disabled'}`, value: 'toggle_data_processing' },
                { name: `Cooldown: ${scenarioConfig.cooldownMs || 100}ms`, value: 'set_cooldown' },
                { name: `Logging: ${scenarioConfig.enableLogging ? '‚úÖ Enabled' : '‚ùå Disabled'}`, value: 'toggle_logging' },
                { name: '‚Ü©Ô∏è  Back', value: 'back' }
            ];

            const choice = await select({
                message: 'üéØ Scenario Settings:',
                choices: choices
            });

            switch (choice) {
                case 'change_game_mode':
                    await this.showGameModeSelection();
                    break;
                    
                case 'toggle_data_processing':
                    await this.configManager.setDataProcessingEnabled(!scenarioConfig.dataProcessingEnabled);
                    console.log(`üéØ Data processing ${!scenarioConfig.dataProcessingEnabled ? 'enabled' : 'disabled'}`);
                    break;
                    
                case 'set_cooldown': {
                    const cooldownInput = await input({
                        message: 'Enter scenario cooldown (ms):',
                        default: String(scenarioConfig.cooldownMs || 100),
                        validate: (value) => {
                            const num = parseInt(value);
                            return !isNaN(num) && num >= 0 && num <= 5000 ? true : 'Please enter a number between 0 and 5000';
                        }
                    });
                    
                    await this.configManager.setScenariosConfig({
                        ...scenarioConfig,
                        cooldownMs: parseInt(cooldownInput)
                    });
                    console.log(`‚è±Ô∏è  Cooldown set to ${cooldownInput}ms`);
                    break;
                }
                    
                case 'toggle_logging':
                    await this.configManager.setScenariosConfig({
                        ...scenarioConfig,
                        enableLogging: !scenarioConfig.enableLogging
                    });
                    console.log(`üìù Scenario logging ${!scenarioConfig.enableLogging ? 'enabled' : 'disabled'}`);
                    break;
                    
                case 'back':
                    return;
            }
        } catch (error) {
            if (error.name !== 'ExitPromptError') {
                console.error('‚ùå Scenario config error:', error.message);
            }
        }
    }

    async configureLogging() {
        try {
            const loggingConfig = this.configManager.getLoggingConfig();
            
            const choices = [
                { name: `Console Output: ${loggingConfig.enableConsoleOutput ? '‚úÖ Enabled' : '‚ùå Disabled'}`, value: 'toggle_console' },
                { name: `File Output: ${loggingConfig.enableFileOutput ? '‚úÖ Enabled' : '‚ùå Disabled'}`, value: 'toggle_file' },
                { name: `Log Level: ${loggingConfig.level || 'info'}`, value: 'set_level' },
                { name: `Log File: ${loggingConfig.logFile || 'logs/velolink.log'}`, value: 'set_file' },
                { name: '‚Ü©Ô∏è  Back', value: 'back' }
            ];

            const choice = await select({
                message: 'üìù Logging Settings:',
                choices: choices
            });

            switch (choice) {
                case 'toggle_console':
                    await this.configManager.update({
                        logging: {
                            ...loggingConfig,
                            enableConsoleOutput: !loggingConfig.enableConsoleOutput
                        }
                    });
                    console.log(`üì∫ Console logging ${!loggingConfig.enableConsoleOutput ? 'enabled' : 'disabled'}`);
                    break;
                    
                case 'toggle_file':
                    await this.configManager.update({
                        logging: {
                            ...loggingConfig,
                            enableFileOutput: !loggingConfig.enableFileOutput
                        }
                    });
                    console.log(`üìÑ File logging ${!loggingConfig.enableFileOutput ? 'enabled' : 'disabled'}`);
                    break;
                    
                case 'set_level': {
                    const levelChoice = await select({
                        message: 'Select log level:',
                        choices: [
                            { name: 'Debug (most verbose)', value: 'debug' },
                            { name: 'Info (default)', value: 'info' },
                            { name: 'Warning', value: 'warn' },
                            { name: 'Error (least verbose)', value: 'error' }
                        ]
                    });
                    
                    await this.configManager.update({
                        logging: {
                            ...loggingConfig,
                            level: levelChoice
                        }
                    });
                    console.log(`üìä Log level set to ${levelChoice}`);
                    break;
                }
                    
                case 'set_file': {
                    const fileInput = await input({
                        message: 'Enter log file path:',
                        default: loggingConfig.logFile || 'logs/velolink.log'
                    });
                    
                    await this.configManager.update({
                        logging: {
                            ...loggingConfig,
                            logFile: fileInput
                        }
                    });
                    console.log(`üìÑ Log file set to ${fileInput}`);
                    break;
                }
                    
                case 'back':
                    return;
            }
        } catch (error) {
            if (error.name !== 'ExitPromptError') {
                console.error('‚ùå Logging config error:', error.message);
            }
        }
    }

    showCurrentConfig() {
        const config = this.configManager.getConfig();
        
        console.log('\n‚öôÔ∏è  Current Configuration');
        console.log('========================');
        console.log(JSON.stringify(config, null, 2));
        console.log('========================\n');
    }

    async reloadConfig() {
        try {
            await this.configManager.loadConfig();
            await this.applyConfiguration();
            console.log('‚úÖ Configuration reloaded successfully');
        } catch (error) {
            console.error('‚ùå Failed to reload configuration:', error.message);
        }
    }

    showPendingData() {
        const status = this.scenarioHandler.getDataProcessingStatus();
        
        console.log('\nüì• Pending Data Status');
        console.log('======================');
        console.log(`Processing: ${status.enabled ? '‚úÖ Enabled' : '‚è∏Ô∏è Disabled'}`);
        console.log(`Pending commands: ${status.pendingDataCount}`);
        console.log(`Current game mode: ${status.currentGameMode.name}`);
        
        if (status.pendingDataCount > 0) {
            console.log('\nüí° Enable data processing to execute buffered commands');
        }
        console.log('======================\n');
    }

    clearPendingData() {
        const count = this.scenarioHandler.clearPendingData();
        console.log(`\nüóëÔ∏è Cleared ${count} pending commands\n`);
    }

    async showDataProcessingPrompt() {
        try {
            console.log('\n‚ö†Ô∏è DATA PROCESSING CONTROL ‚ö†Ô∏è');
            console.log('==============================');
            console.log('Data processing is currently DISABLED.');
            console.log('Enable it to allow Arduino commands to trigger key actions.');
            
            const choice = await select({
                message: 'Choose data processing option:',
                choices: [
                    { name: '‚úÖ Enable now', value: 'enable' },
                    { name: '‚è∏Ô∏è Keep disabled (use menu later)', value: 'disabled' },
                    { name: 'üìö Show help', value: 'help' }
                ]
            });

            switch (choice) {
                case 'enable':
                    this.scenarioHandler.enableDataProcessing();
                    console.log('‚úÖ Data processing enabled! Arduino commands will now work.');
                    break;
                case 'disabled':
                    console.log('‚è∏Ô∏è Data processing remains disabled. Use menu to enable later.');
                    break;
                case 'help':
                    this.showDataProcessingHelp();
                    break;
            }

        } catch (error) {
            if (error.name === 'ExitPromptError') {
                console.log('‚è∏Ô∏è Data processing remains disabled.');
                return;
            }
            console.error('‚ùå Error in data processing prompt:', error.message);
        }
    }

    showDataProcessingHelp() {
        console.log('\nüìö Data Processing Help');
        console.log('=======================');
        console.log('üéØ Purpose: Control when Arduino commands trigger keyboard actions');
        console.log('');
        console.log('‚úÖ ENABLED:');
        console.log('  - Arduino commands immediately trigger key presses');
        console.log('  - Perfect for active gaming/control');
        console.log('  - Real-time response');
        console.log('');
        console.log('‚è∏Ô∏è DISABLED:');
        console.log('  - Arduino commands are buffered (stored)');
        console.log('  - No accidental key presses');
        console.log('  - Safe for setup and testing');
        console.log('');
        console.log('üí° Tips:');
        console.log('  - Start with DISABLED for safety');
        console.log('  - Enable when ready to play/use');
        console.log('  - Use menu option 6 to toggle anytime');
        console.log('=======================\n');
    }

    async sendCommand(command) {
        if (!this.isConnected) {
            console.log('‚ùå Not connected to HC-05');
            return;
        }

        try {
            await this.bluetoothManager.sendData(command);
            console.log('üì§ Sent to Arduino:', command);
        } catch (error) {
            console.error('‚ùå Failed to send command:', error.message);
        }
    }

    getStatus() {
        return {
            connected: this.isConnected,
            port: this.bluetoothManager.getCurrentPort()
        };
    }
}

// Application entry point
async function main() {
    console.log('üéØ Starting Velolink Client Desktop Application');
    console.log('=' .repeat(50));
    
    const client = new VelolinkClient();
    await client.initialize();
    
    // Show interactive menu
    await client.showMainMenu();
}

// Run the application
if (require.main === module) {
    main().catch(error => {
        console.error('üí• Application crashed:', error);
        process.exit(1);
    });
}

module.exports = VelolinkClient;
